
** Instantiating New Threads

        * First way
        public class MyThread extends Thread {

            private final int mSeed;

            public MyThread (int seed){
               mSeed = seed;
            }

            @Override
            public void run(){
               // perform some calculation
            }
        }

        Thread thread = new MyThread(10);
        thread.start();

        ------------------
        * Second way
        Runnable runnable = new Runnable (){
           @Override
           public void run (){
               int seed = 10;
               // perform some calculation
           }
        }

        Thread thread = new Thread (runnable)
        thread.start();


** Important roots in android application (Memory leak)

   1. Objects referenced from static fields
   2. Instances of Application class
   3. Live threads

   Anonymous Threads
   if you use a Thread with no name like this

      class MainActivity extends AppCompatActivity {
          onCreate(){
             new Thread(new Runnable()) {
                @Override
                public void run(){

                }
             }.start();
          }
      }

   this causes memory leak in MainActivity.

** Thread Termination Strategies

   1. Return from run() after successful execution

            class MainActivity extends AppCompatActivity {

            private FetchItemsEndpoint mFetchItemsEndpoint;
            private itemsDao mItemsDao;

                onCreate(){
                   new Thread(new Runnable()) {
                      @Override
                      public void run(){
                         List <Item> items = mFetchItemsEndpoint.fetch();
                         mItemsDao.insertItems(items)
                      }
                   }.start();
                }
            }

        Anonymous Thread can access Activity's fields because it has implicit
        reference to the enclosing object.

   2. Return from run() in response to internal error

      class MainActivity extends AppCompatActivity {

              private FetchItemsEndpoint mFetchItemsEndpoint;
              private itemsDao mItemsDao;

                  onCreate(){
                     new Thread(new Runnable()) {
                        @Override
                        public void run(){
                           List <Item> items;
                           try{
                              items = mFetchItemsEndpoint.fetch();
                           } catch(IOException e){
                               return;
                           }
                           mItemsDao.insertItems(items)
                        }
                     }.start();
                  }
              }

        When you return in an error there is no problem for memory leak.

   3. Return from run() in response to externally set flag

        class MainActivity extends AppCompatActivity {

                      private FetchItemsEndpoint mFetchItemsEndpoint;
                      private itemsDao mItemsDao;
                      private AtomicBoolean mFetchAborted = new AtomicBoolean(false);

                          onCreate(){
                             new Thread(new Runnable()) {
                                @Override
                                public void run(){
                                   List <Item> items = mFetchItemsEndpoint.fetch();
                                   if (mFetchAborted.get()){
                                      return;
                                   }
                                   mItemsDao.insertItems(items)
                                }
                             }.start();
                          }
                      }

   4. Return from run() in response to interruption

         class MainActivity extends AppCompatActivity {

                      private FetchItemsEndpoint mFetchItemsEndpoint;
                      private itemsDao mItemsDao;
                      private Thread thread;

                          onCreate(){
                             thread = new Thread(new Runnable()) {
                                @Override
                                public void run(){
                                   List <Item> items = mFetchItemsEndpoint.fetch();
                                   if (thread.interrupted()){
                                      return;
                                   }
                                   mItemsDao.insertItems(items)
                                }
                             }
                             thread.start();
                          }
                      }

         - to interrupt a thread from outside, we need to have a reference to it
         - thread interruption might look like externally set flag, but
           it is much more nuanced and complex mechanism

** UI Thread Characteristics 

    1. Started by Android Framework when application start
    2. Terminated only when application's process terminates
    3. Application's user interface is "drawn" on UI thread
    4. Lifecycle callbacks (e.g onStart(),onStop()) are executed on UI thread
    5. User interaction event handlers (e.g onClick()) are executed on UI thread
    6. Changes of user interface must be performed on UI thread


